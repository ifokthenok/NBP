g++编程命令

1)直接编译
g++ -o prg prg.cpp                // 编译成可执行的prg
g++ -I/dev/mycode -o prg prg.cpp  // -I指定包含文件所在目录:/dev/mycode

2)间接编译
g++ -c prg1.cpp prg2.cpp      // 生成prg1.o, prg2.o
g++ -o prg prg1.o prg2.o      // 生成可执行的prg(如果prg.cpp或prg2.cpp中有main)

3)编译为库
ar crv prg.a prg1.o prg2.o   // 将prg1.o和prg2.o打包成静态库
ranlib prg.a                 // 为兼容一些GNU软件开发工具包(推荐增加此命令)

4)等价编译
g++ -o app app.o  -L../../lib -lmy   // 与下面的命令等价(-L后表示目录, -lmy表示libmy.a或libmy.so)
g++ -o app app.o ../../lib/libmy.a   // 编译成可执行的app(指明连接库../../lib/libmy.a)
类似文件比较: 
linux   windows     
prg.o   prg.obj   // 目录文件
prg.a   prg.lib   // 静态库
prg     prg.exe   // 可执行文件
prg.so  prg.dll   // 动态链接库(或共享库)

5)查看库
nm  prg.o     // 可查看prg.o包含了哪些函数解(也可查看可执行的prg)
ldd prg       // 可查看可执行文件prg引用了哪些共享库
注：此外还有一些有用的工具：
ar              // 创建静态库，插入，删除，列出和提取成员
strings         // 显示文件中所有可打印的字符串
size			// 列出目标文件中节的名字和大小
readelf		    // 显示一个目标文件的完整结构，包括ELF头中编码的所用信息（包含size和nm功能）
objdump		    // 能够显示目标文件的所有信息（最大作用反汇编.text节中的二进制指令）
c++filt			// C++编译时会改名（如重载函数、模板等），此工具用于输出可读的C++符号
ind             //

6)查找字符串
grep #define prg.cpp      // 查找prg.cpp文件内容包括#define

7)关于makefile
make -k                   // 当错误发生时继续
make -n                   // 打印将要执行的命令（实际并不执行）
make -f [makefile文件名]  // 使用makefile文件建立
a.makefile文件写法要点: a.依赖性; b.规则.
Example:
app: app.o file1.o file2.o             // app依赖app.o file1.o file2.o
	g++ -o app app.o file1.o file2.o     // 得到app目标规则是g++ -o app app.o file1.o file2.o
app.o: app.cpp app.h
	g++ -c testlib.cpp
file1.o: file1.cpp
	g++ -c file1.cpp
file2.o: file2.cpp
	g++ -c file2.cpp
注: 规则所在行必须以Tab分开(不能为Space),行结束符节不能为Space或Tab.
b.makefile注释:
以#开始,结束于行(#相当于单行注释)
c.makefile变量
MACRONAME = value
替换时,以value替换$(MACRONAME), $(MACRONAME)或$MACRONAME
d.三个有用的预定变量
	$@ 扩展成当前依赖的目的文件名 
	$< 扩展成依靠列表中的第 一个依赖文件 
	$^ 扩展成整个依赖的列表（除掉了里面所有重复的文件名）

8)GCC的一些选项说明
a.无选项编程链接
用法：gcc test.c
作用：将test.c预处理、汇编、编译并链接形成可执行文件a.out
    
b.选项-E
用法: gcc -E test.c 
作用：将test.c预处理输出test.i

c.选项 -S
用法：#gcc -S test.i
作用：将预处理输出文件test.i汇编成test.s

d.选项 -S
用法：#gcc -c test.s 
作用：将test.s编成test.o

注：分析一些中间文件，有时很有意义。比如分析预处理后生的文件可以查看宏展开后最终的模样。
查看生成的汇编程序可以优化程序性能（如何写C/C++代码，使得生成的汇编更有效）

9)动态库
静态编译动态库:
$ gcc -fPIC -c dl_1.c                   // 编译为dl_1.o        
$ gcc -fPIC -c dl_2.c                   // 编译为dl_2.o        																																																								
$ gcc -shared dl_1.o dl_2.o -o dl.so    // 编译为动态库dl.so   																																																																																			
$ gcc test.c dl.so -o test              // 生成可执行文件test
注: 可用ldd测试
$ ldd test
    ld.so => not found
    libc.so.6 => /lib/tls/libc.so.6 (0x42000000)
    ...

大多可执行文件依赖下面两个共享库：
/lib/ld-linux.so.N 　// 动态库加载器，N表示版本号，用于加载其它库
libc.so.N 　			 // 表示C库，N为版本号


如何才能让动态加载器发现库文件呢? 
1.修改环境变量LD_LIBRARY_PATH使包括动态库所在目录, 如:
	export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:."
2.利用/lib/ld-linux.so.2来执行程序，如使用<so-search-dirs>来替代LD_LIBRARY_PATH
 　/lib/ld-linux.so.2 --library-path <so-search-dirs> <exe-file> [<args>]

动态加载动态库:  
可能需要用到以下函数
    void *dlopen( const char *filename, int flag );    // 打开动态库,获取其句柄
    const char *dlerror( void );                       // 返回出错字符串
    void *dlsym( void *handle, char *symbol );         // 查询接口函数
    int dlclose( void *handle );                       // 关闭动态库句柄
编译方法与前述相同
$ gcc -fPIC -c dl_1.c                   // 编译为dl_1.o        
$ gcc -fPIC -c dl_2.c                   // 编译为dl_2.o
$ gcc -shared dl_1.o dl_2.o -o dl.so    // 编译为动态库dl.so
$ gcc -rdynamic -ldl test.c -o test     // test.c中调要加载动态库的函数即可
注: 如果是C++程序, 用extern "C"作用, 否则找不到指定的函数(C++编译生成目标时函数名会改变)
注: 关于共享库的几点说明：
a. 共享库的名字
共享库名（so name）: lib<xxx>.so.<version-name>　// 如libavcodec.so.56, 56表示库接口变化，一般链接到真实文件
真实名（real name）: lib<xxx>.so.<version-name>.<minor-number>.<release-number>	// 如libavcodec.so.56.41.100
连接名（linker name）: lib<xxx>.so　　// 编译器使用的名字，如libavcodec.so，一般为链接到真实文件
b.共享库在文件系统中的位置
开源项目大多遵守GNU标准，共享库放在/usr/local/lib，可执行文件放在/usr/local/bin
FHS（Filesystem Hierarchy Standard）标准要求：大多数库放在/usr/lib，启动时需要的库放在/lib,　非System库放在/usr/local/bin
c.库如何被加载
GNU glibc基于的系统（包括Linux）执行ELF文件时，启动加载器/lib/ld-linux.so.X(其中X为版本号)来加载其它共享库，、
此加载器搜索/etc/ld.so.conf指定的一系列目录来查找共享库，而在每个程序执行时都搜索所有共享库并非有效做法，
ldconfig读取/etc/ld.so.conf在动态库目录下建立符号链接，并缓存在/etc/ld.so.cache中以便其它程序使用，这意味
着当一个共享库变化，应该再次运行ldconfig来更新缓存（很多包管理器正是这样做的）
d.环境变量
LD_LIBRARY_PATH　// 冒号分隔的共享库目录，在搜索标准目录之前，先搜索此变量指定的目录


10)调试程序
# gcc -g test.c -o test    // 加-g选项使生成可用gdb调试的映像

GDB工具的使用:
help                    // 获取帮助信息
help break              // 获取break帮助信息

启动程序
gdb exec_file										// 调试文件exec_file
gdb -args exec_file arg1 arg2		// 调试文件exec_file并传入参数arg1, arg2

gdb exec_file						// 或者先启动gdb
gdb run arg1 arg2       // 传入arg1 arg2并运行
gdb start arg1 arg2     // 传入arg1 arg2运行至main的第一行
Ctrl + C								// 暂停
cont										// 继续运行	


list                    // 查看源代码
list 50 80              // 查看50-80行代码

break                   // 设置断点
设置命令                设置方式
break function          Set a breakpoint at a function
break file : function   Set a breakpoint at a function
break line              Set a breakpoint at a line number
break file:line         Set a breakpoint at a line number
break address           Set a breakpoint at a physical address
tbreak									// 临时断点
info breakpoints				// 列出所有断点
条件断点
break file:line						// 先设断点(GDB会提示这个断点的编号，比如2)
condition 2 <测试的条件>	// 如果测试条件满足，程序将在此停下
commands 2                // 也可在断点处执行命令(GDB会提示输入命令)

比如:
break main              // 在main函数处中断
break test.c : 30       // 在test.c的第30行中断
break C::foo

clear                   // 清除断点
clear 79                // 清除第79行的断点

run                     // 继续运行

info                    // 显示相关信息
info breakpoints        // 显示断点信息

break operator if <condition>  // 设置条件断点
break operator if op = 2       // 当op = 2时中断

步进调试:
命令 (快捷方式)       执行的操作 
next (n)             Execute next line, step over functions
step (s)             Execute next line, step into functions
finish               Step out of functions

nexti (ni)           Execute next machine instruction
stepi (si)           Step by machine instruction

cont (c)             Continue execution

display  Var                 // 查看变量Var的值(Var可以是函数地址,指针,结构体等)
display 'file2.c'::variable  // 可以此种方式查看静态变量

print var                    // 输出变量的当前值（Display命令只需执行1次，其查看的变量每次都会更新）
watch expr									 // 监视表达式的值
ptype val										 // 显示变量类型信息（可以列出结构体成员）
whatis val									 // 输出类型
x val												 // 输出内存内容

改变数据的例子:
(gdb) set stack->stack[9] = 999
(gdb) p *stack                  // 打印stack指向的内容
$11 = {stack = {2, 0, 1107383313, 134513378, 
1108545272, 1108544020, -1073743096, 134513265, 
1108544020, 999}, index = 1}
(gdb)

函数：
info functions expr				// 查找函数
call expr									// 调用函数			
return expr								// 修改函数返回值

信号捕捉：
handle SIGUSR1 print nostop pass			// 收到信号SIGUSR1时打印、后继续运行，并将信号传给程序
handle SIGUSR1 noprint nostop nopass 	// 忽略信号SIGUSR1
signal SIGUSR1 												// 向被调程序发给信号

异常捕获：
catch throw							// 调试器在抛出任何异常时停上
catch catch 						// 调试器在捕获任何异常时停上

栈跟踪（是一个帧列表，每个帧对应一个被调用函数，可能包括函数名和参数信息）
where                   // 显示当然调用栈帧

bt     // 检查调用堆栈(bt: backtrace的简写)
Quit   // 退出gdb,当然也可用Ctrl+C键

Core Dump:
ulimit -a                       // 查看系统资源限制，其中一行就包括core dump信息，如 "core file size (blocks, -c) 0"
ulimit -c 						// 查看Core Dump文件大小（0表示不会创建core dump文件）
ulimit -c 1024  				// 设置Core Dump文件大小限制为1024K（大于1024K则不会创建）
ulimit coredumpsize 1000000 	// 如果coredump文件天于1000000字节则不创建（对于tcsh/csh）
注：
Core Dump文件的路径通过/proc/sys/kernel/core_pattern设置，其它如/proc/sys/kernel/core_uses_pid可参考：https://www.kernel.org/doc/Documentation/sysctl/kernel.txt
core_pattern指定Core Dump路径pattern, 如果pattern以"|"开头，则pattern的剩余部分作为命令对待（Core Dump文件作为该命令的标准输入） 
core_pattern最大128字符，缺省值为"core"(如果设置core_uses_pid为１，则为"core.PID")
如果core_pattern不包括"%"（缺省不包括），core_uses_pid将会被设置，.PID将添加作为Core Dump文件名的后辍
core_pattern如下：
%<NUL> 		'%' is dropped 
%% 			output one '%' 
%p 			pid 
%P 			global pid (init PID namespace) 
%i 			tid 
%I 			global tid (init PID namespace) 
%u 			uid (in initial user namespace) 
%g 			gid (in initial user namespace) 
%d 			dump mode, matches PR_SET_DUMPABLE and /proc/sys/fs/suid_dumpable 
%s 			signal number 
%t 			UNIX time of dump 
%h 			hostname 
%e 			executable filename (may be shortened) 
%E 			executable path 
%<OTHER> 	both are dropped

查看正在使用的core文件路径和格式：
more /proc/sys/kernel/core_pattern

修改core文件的保存路径和文件名格式：
修改/etc/sysctl.conf 中kernel.core_pattern = /tmp/corefile/core.%e.%t
并执行sysctl -p生效

附上core文件支持的格式列表：
%p C insert pid into filename 【pid】
%u C insert current uid into filename 【uid】
%g C insert current gid into filename 【gid】
%s C insert signal that caused the coredump into the filename 【core信号】
%t C insert UNIX time that the coredump occurred into filename 【core文件生成时的unix时间】
%h C insert hostname where the coredump happened into filename 【主机名】
%e C insert coredumping executable name into filename 【应用的名字】

多线程：
info threads	// 给出当前所有线程信息（当前线程前有*号，实际创建的线程数可能多于pthread_crate创建的 + main线程）
thread 3			// 切换到线程3
bt						// 查看线程3的调用栈
break 88 thread 3 						// 当线程3到达88行时，停止执行
break 88 thread 3 if x == y		// 当线程3到达88行并且x==y时，停止执行

C/S模式的调试方法：
a) 编译（加上-g选项）
gcc -0 test -g test.c
b) 运行gdbserver
gdbserver localhost:2000 ./test [args]
c) 运行gdb客户端
gdb
symbol-file test.exe
target remote localhost:2000


11) 测试覆盖率（gcov & lcov）
gcc -fprofile-arcs -ftest-coverage -o main main.cpp // 编译加选项-fprofile-arcs -ftest-coverage, 可能需链接选项-lgcov
                                                    // 编译后生成main.gcno

./main                                              // 运行此程序
                                                    // 运行后生成main.cpp.gcda
收集coverage
1) 使用gcov
  gcov main.cpp                                     // 运行后可查看单个cpp相关信息, 生成main.cpp.gcov, <其它>.cpp.gcov
或gcov main.cpp.gcno
或gcov main.cpp.gcda
2) 使用lcov
lcov --directory <.gcno/.gcda所在目录> --capture --output-file app.info // 运行后收集信息 --capture指示收集coverage数据
 
genhtml -o results app.info                         // 将其转化为html, -o指定输出目录
注: 　
1) gcov属于GNU工具(随GCC附带)，lcov(或类似的gcovr)需另行安装
2) 编译选项不能加优化标志，否则coverage统计不准确, 此外宏也会影响coverage统计
3) gcov使用两类文件，文件名由相应obj文件后辍换成.gcno/.gcda后得到.缺省情况下与obj文件同目录（可通过-fprofile-dir改变）
　　　.gcno编译时生成，如果obj编译时指定了-ftest-coverage选项
   .gcda运行时生成，如果程序包含的obj编译时指定了-fprofile-arcs选项
4) .gcno, .gcda格式平台无关，所以lcov/gcovr工具也能收集其coverage信息


12) 对重定义的全局符号输出警告
gcc -fno-common 					                // 告诉链接器对重定义的全局符号输出警告

13)内存检查工具valgrind
gcc -g -O0 -o app ...								// 编译（-g选项加调试信息，-O0尽量不要优化）
valgrind --leak-check=yes app arg1 arg2			    // 运行（检查内存泄露）
valgrind --tool=helgrind app arg1 arg2              // 运行（使用helgrind工具分析线程）

14)调用工具strace
strace -f -o starce.log app arg1 arg2               // 可跟踪文件IO/系统调用/内存分配、释放等

15) configure
Linux下载源码安装是往往先使用configure配置生成Makefile再make，configure是autoconf的工具的基本应用。
一般常见选项:
--help					    // 显示帮助
--version					// 打印用来产生'configure'脚本的autoconf的版本号. 
--prefix=PEWFIX				// 常用选项。比如指定安装它的结构独立部分的位置
--bindir=DIR				// 指定二进制文件目录
--sbindir=DIR				// 超级用户执行的二进制目录
--libexecdir=DIR			// 与二进制文件不一样，一般用户不直接调用，而由其它程序调用执行
--includedir=DIR			// 指定头文件的安装位置.
--libdir=DIR				// 指定库文件的安装位置.
--datadir=DIR				// 指定通用数据文件的安装位置.
--sysconfdir=DIR			// 指定在单个机器上使用的只读数据的安装位置.	
--sharedstatedir=DIR	    // 指定可以在多个机器上共享的可写数据的安装位置.	
--localstatedir=DIR		    // 指定只能单机使用的可写数据的安装位置.

16) strip(从文件中移除symbol和sections)
Usage: 
    strip <option(s)> in-file(s)
options:
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>
  -O --output-target=<bfdname>     Create an output file in format <bfdname>
  -F --target=<bfdname>            Set both input and output format to <bfdname>
  -p --preserve-dates              Copy modified/access timestamps to the output
  -R --remove-section=<name>       Remove section <name> from the output
  -s --strip-all                   Remove all symbol and relocation information
  -g -S -d --strip-debug           Remove all debugging symbols & sections
     --strip-unneeded              Remove all symbols not needed by relocations
     --only-keep-debug             Strip everything but the debug information
  -N --strip-symbol=<name>         Do not copy symbol <name>
  -K --keep-symbol=<name>          Do not strip symbol <name>
     --keep-file-symbols           Do not strip file symbol(s)
  -w --wildcard                    Permit wildcard in symbol comparison
  -x --discard-all                 Remove all non-global symbols
  -X --discard-locals              Remove any compiler-generated symbols
  -v --verbose                     List all object files modified
  -V --version                     Display this program's version number
  -h --help                        Display this output
     --info                        List object formats & architectures supported
  -o <file>                        Place stripped output into <file>

17) GCC常见用法总结
语法： gcc [options] [source files] [object files] [-o output file]
options:
gcc -c 	                编译源文件为object文件（without linking）
gcc -Dname[=value] 	    定义宏
gcc -Uname 	            不定义宏
gcc -shared 	        生成可重定位的的object文件（for shared library）
gcc -fPIC 	            生成可重定位的代码（for shared library）
gcc -glevel 	        产生debug信息
gcc -Idir 	            指定include目录
gcc -llib 	            指定链接的库
gcc -Ldir 	            库文件的搜索目录
gcc -o output file 	    指定输出文件
gcc -Olevel 	        优化级别
gcc -w 	                disable所有warning
gcc -Wall 	            enable所有warning
gcc -Wextra 	        enable所有extra warning
gcc -static             静态链接
gcc --sysroot=dir       通常搜索头文件和库在目录：/usr/include和/usr/lib，指定此先项后将搜索（dir/usr/include和dir/usr/lib）
gcc -isysroot=dir       用于指定头文件搜索（如果同时指定了--sysroot,　则库目录由--sysroot指定）
注：
1)链接静态库的例子（注意加了-static选项）
gcc -static myfile.c -L/user/local/math -lmath -o execfile
2)不能静态链接shared库，也不能动态加载static库


18) GCC头文件搜索目录
#include <file>搜索以下缺省目录：

/usr/local/include
<libdir>/gcc/<target>/<version>/include
/usr/target/include
/usr/include

C++程序将首先搜索：<libdir>/../include/c++/<version>
如果指定了-I选项，则首先以从左到右顺序搜索-I指定的目录，然后才搜索缺省目录。（例外情况是：-I选项指定的目录已在被搜索过了，此时忽略-I选项）
#include "file"则首先搜索包含当前文件的目录，然后搜索-iquote选项指定的目录，最后搜索<file>形式的目录

注：可以用-I-选项来分隔一系列-I指定的目录，　-I-之前的目录用于引号""形式的头文件搜索，-I-之后的目录用于引号和尖括号（""和<>）形式的头文件搜索。
    如果指定了-I-选项，则当前文件所有的目录将不会被搜索（某些情况如单元测试中，这个选项很有用）， 但-I-是遗留的选项，GCC建议使用-iquote选项。


19) gprof (GNU Binutils工具，profiling程序的执行时间)
gprof可用于检测程序执行时间、函数调用关系（调用了哪此函数，被哪些函数调用）
使用步骤：
a. 编译程序: 编译和链接时都需要加"-pg"选项（如: gcc -o myprog myprog.c -pg）
b. 执行程序: 像普通程序一样传入参数运行即可（运行中会产生gmon.out，程序应正常退出，确保profile数据完全写入gmon.out）
c. 解析profile数据: gprof输出Flat Profile和Call graph到stdout,　exe-file为可执行文件（缺省为a.out）, profile-files可为多个profile文件（缺省为gmon.out）
   gprof [options [exe-file [profile-files...]] [> outfile]

gprof可产生不同类型输出：
   Flat Profile:     输出每个函数执行时间
   Call Graph:       输出每个函数调用了哪些函数，被哪些函数调用，每个函数执行时间（分为函数自身执行，和子函数执行时间）
   Line-by-line:     输出源代码行
   Annotated Source: 输出源代码行（标记代码的执行次数）

Call Graph输出例子：
granularity: each sample hit covers 2 byte(s) for 5.20% of 0.19 seconds

index % time    self  children    called     name
                0.19    0.00   10000/10000       my_mul [2]
[1]    100.0    0.19    0.00   10000         my_add [1]
-----------------------------------------------
                0.00    0.19       1/1           main [3]
[2]    100.0    0.00    0.19       1         my_mul [2]
                0.19    0.00   10000/10000       my_add [1]
-----------------------------------------------
                                                 <spontaneous>
[3]    100.0    0.00    0.19                 main [3]
                0.00    0.19       1/1           my_mul [2]
-----------------------------------------------
注：
index       函数索引，index上面的行为父函数（调用此函数的函数），index下面的行为子函数（此函数调用的函数）
%time       通常100%(但有些函数通过选项排除后可能<100%) 
self        函数自身执行时间
children    子函数执行时间
called      函数被调用次数
name        函数名（后跟索引）




