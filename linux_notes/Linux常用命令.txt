Linux常用命令

1)man
帮助命令.如: man ls
注：按q键或者ctrl+c退出，在linux下可以使用ctrl+c终止当前程序运行

2)echo
echo 'hello world'　     // 输出hello world, 但会输出一个换行符
echo -n 'hello world'    // 使用-n选项禁止输出一个换行符
echo -e 'hello/tworld'   // 使用-e选项可以输出转义输入出（如\t转义为Tab输出）

3)ls
列目录信息(类似dir)
以长格式来显示文件的详细信息(这个选项最常用): ls -l 目录名
-d 只列出目录
-a 列出包括隐藏的（.Documents/linux/Notes/Linux基础知识.TXT:file-or-dir）所有文件及目录（包括. 和 ..）
-A 与－a选项类似，除了不包括. 和 ..
-F 在文件或目录名后增加*/=>@|标识文件或目录类型（比如：目录名后增加/标识其为目录）
-t 以修改时间排序（最新的文件排在第1位）
-S 以文件Size排序
-h 更人性化地显示结果:)

4)pwd
列出当前路径

5)cd 
转向某个目录
.. 代表父目录
-  代表上一个目录
~  代表用户的根目录

6)cp
拷贝文件或目录.如:
cp filename1 filename2  // 把文件filename1拷贝成filename2 
cp 1.c netseek/2.c      // 将1.c拷到netseek目录下命名为2.c 
cp -r dir1 di2          // 把目录dir1拷贝成dir2

7)touch
更新文件时间（访问和修改时间）

8)rm 
删除文件或目录.

9)mkdir
创建目录

10)rmdir
删除空目录
注:删除非空目录使用: rm -r 目录名

11)su
切换用户.如: 
su user2    // 切换到用户user2,系统提示输入根口令, 输入之后则可切换到user2
            // 完成之后可以用exit命令返回          
注:
如果不带用户名的su命令,则系统提示输入根口令,输入之后则可切换为根用户;
如果登录为根用户,则可以用su命令成为系统上任何用户而不需要口令.

12) 压缩与解压
*.gz格式的压缩与解压
压缩 gzip
解压 gunzip (gzip -d具有类似功能)

*.zip格式的压缩与解压：
压缩 zip -r filename.zip filesdir 
将filesdir目录压缩成filename.zip其中r表示递归
解压 unzip -o -d /home/sunny myfile.zip
将myfile.zip文件解压到 /home/sunny/（-o:覆盖文件且不提示；-d 解压到指定目录）

*.rar格式解压：
unrar e file.rar			// 解压 file.rar 到当前目录
unrar x file.rar spec-dir   // 解压file.rar到目录spec-dir

*.7z格式解压：
7z x file.7z				// 解压 file.7z 到当前目录
7z a file.7z file1 file2 	// 压缩file1 file2到file.7z

*.ipk格式解压
*.ipk格式通常就是.tar.gz文件，所以可以使用
tar -xzf some-package.ipk            
某些ipk采用不同的压缩方式
ar x some-awesome-package.ipk   // 解压出./debian-binary, ./data.tar.gz 和./control.tar.gz.
tar xvfz control.tar.gz         // 解压一次

13)tar
用于建立文件发布档案.如:
tar cvf ye.tar *.*  // 将当前目录中所有文件存档到ye.tar中
tar tvf ye.tar      // 浏览ye.tar档案中的内容
tar xvf ye.tar      // 将ye.tar档案中的内容取到当前目录中
注: tar实际上是将文件或目录打包

tar   -xzvf 	linux-2.6.20.tar.gz			// 解压.tar.gz
tar   -xjvf   linux-2.6.20.tar.bz2 		// 解压.tar.bz2

相关选项： 
x：解压 
j：bz2
z: gz 
f：指定文件

14)ps
查看进程信息
ps -ef          // 显示所有进程
ps -efH         // 以层次形式显示所有进程

15)输入输出重定向
ls dir > outfile       // 将ls dir的标准输出结果输出到outfile文件
ls dir >& outfile      // 将ls dir的标准输出结果和标准错误输出结果都写入outfile文件
ls dir >> outfile      // 将ls dir的标准输出结果追加到outfile文件
ls dir >>& outfile	   // 将ls dir的标准输出结果和标准错误输出结果都追加到outfile文件

kill -HUP 1234 >killout.txt 2>killerr.txt
                       // 将kill -HUP 1234的标准输出和标准错误输出结果分别写入killout.txt和killerr.txt文件
注:文件描述符: 0<代表标准输入, 1>代表标准输出, 2>代表标准错误输出 
ls < dir               // 将dir作为ls的输入参数
ps | sort > outfile    // 用ps命令显示进程信息,将进程信息排序输出到outfile文件
注: 管道操作符" | "用于连接一系列进程的执行.

16)关于通配符*, ?, [], {}
*                    // 可匹配任意长度字符串
?                    // 可匹配单个字符
a[bcd]               // 可匹配ab, ac, ad
a[b-f]               // 可匹配ab, ac, ..., af
a[^b]                // 可匹配除ab以外a?
my_{aaa, bbb}file    // 可匹配my_aaafile,my_bbbfile

17)cat查看文件内容
cat -n file					// 查看file内容并显示行号
cat -s file					// 压缩file中多个空行为单个空行
cat -T file					// 文件file中的制表符/t以^I显示

18)设置环境变量
1)修改/etc/profile并重新登陆（所有用户有效）
2)修改~/.bashrc并重新登陆(当前用户有效)
3)export PATH=$PATH:~/bin（当前shell有效）

19)mount/umount
mount [选项] <-t 类型> [-o 挂载选项] <设备> <挂载点>       // 挂载点必须是一个目录
umount <挂载点|设备>                                       // 取消挂载

mount -t iso9660 /dev/hdc /mnt/cdrom   // 将CD-ROM挂载到目录/mnt/cdrom
numout /dev/hdc												 // 取消挂载
umount /mnt/cdrom											 // 取消挂载

20)ln
硬链接：相当于对源文件的一个引用（引用计数加1），使用ln -il 可看到硬链接文件的inode值相同
1）不可以在不同文件系统的文件间建立链接
2）只有超级用户才可以为目录创建硬链（由于系统限制可能失败）

符号链接：对源文件建立了一个链接文件（依据此文件内容找到源文件）

ln -s source dest   // 创建符号链接
ln source dest   	// 创建硬链接

21) 用户管理
useradd yuhao  // 新建用户yuhao, 会在/home目录下新建子目录yuhao
userdel yuhao  // 删除用户yuhao, -p选项删除与用户yuhao相关的其它文件
passwd  yuhao  // 为用户yuhao加密
groupadd yu    // 新建组yu
groupdel yu    // 删除组yu

22)linux重定向
a. 常用FD有3个，为0（stdin，标准输入）、1（stdout，标准输出）、2（stderr，标准错误输出);
b. 用 < 来改变输入的数据信道(stdin)，使之从指定的文件输入;
c. 用 > 来改变输出的数据信道(stdout, stderr)，使之输出到指定的文件（用 >> 表示追加方式）
d. 0 是 < 的默认值，因此 < 与 0< 是一样的；同理，> 与 1> 是一样的;
e. 在IO重定向 中，stdout 与 stderr 的管道会先准备好，才会从 stdin 读进资料;
f. 0< file 表示从描述符0（stdin）的输入定向到从文件file输入
g. 1> file 表示向描述符1（stdout）的输出定向到向文件file输出
h. 注意0，1是写在左边的（>1指stdout定向到文件1, <0从文件0输入）
h. bash（ksh）执行命令的过程：分析命令－变量求值－命令替代（``和$( )）－重定向－通配符展开－确定路径－执行命令；
注：
>&n  使用系统调用dup2复制文件描述符n为描述符1.（描述符1也指向了描述符n所指的文件, 1->n, n不变，效果通常是合并了两个流）
<&n  标准输入复制至文件描述符n（描述符0也指向了描述符n所指的文件。n -> 0, 0不变）
<&-  关闭标准输入；
>&-  关闭标准输出；
n<&- 表示将n号输入关闭；
n>&- 表示将n号输出关闭；
例：cmd > file 2>&1  // 先把描述符1定向到file, 再把描述符2定向到1（自然定向到了file），最终描述符1和描述2都定向到了file
理解：1>n与1>&n, 前者表示描述符1定向到文件名为n的文件，后者定向到描述符为n的文件:)
记忆：注意箭头：2>&1 （2 -> 1，1不变） (0<&n 0 <- n, n不变)

注：
COMMAND_OUTPUT > filename   // 重定向命令到文件
COMMAND_OUTPUT >>　filename  // 追加方式
: > filename            　   // 创建或truncates文件（:作为placeholder）
  > filename                // 创建或truncates文件（某些shell下不工作）  

 0< filename                // 重定向stdin到文件
  < filename

1>filename                  // 重定向stdout到文件
1>>filename                 // 追加方式

2>filename
2>>filename

&>filename                  // 重定向stdout stderr到文件

M>N                         // "M"是文件描述符(缺省为1), "N"是文件
M>&N                        // "M"是文件描述符(缺省为1), "N"是文件描述符(必须指定)

[j]<>filename               // 以读写方式打开filename（不存在，则创建）, 分配描述符为j（缺省为0）             

      #  An application of this is writing at a specified place in a file. 
      echo 1234567890 > File    # Write string to "File".
      exec 3<> File             # Open "File" and assign fd 3 to it.
      read -n 4 <&3             # Read only 4 characters.
      echo -n . >&3             # Write a decimal point there.
      exec 3>&-                 # Close fd 3.
      cat File                  # ==> 1234.67890
      #  Random access, by golly.


注：
bash中还可重定向代码块，例如：　while, until, for, 甚至if/then和函数都可重定向stdin(<操作符添加到代码块后即可）
重定向代码块：
while [ "$name" != Smith ] 
do
  read name                 // 从in.txt读
  echo $name                // 写入out.txt
done < in.txt > out.txt     // 重定向stdin到in.txt, stdout到out.txt

重定向函数：
function doesOutput()
{
  ls -al *.jpg | awk '{print $5,$9}'
}

while read fileSize fileName ; do
  echo "$fileName is $fileSize bytes"
done<<EOF                   // Here文档
$(doesOutput)               // 调用函数
EOF



23)权限管理
chmod [opt] [mode] file..  // 改变文件的权根
[opt]: -R 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) 
[mode]有两种格式：
 a. [ugoa][+-=] 如 chmod -R u+x dir1
     其中：u - user, g - group, o - other, a - all
 b.  chmod ug=rwx,o=x file 和 chmod 771 file 等价。
     chmod a=rwx file 和 chmod 777 file 等价。

chown [opt] user[:group] file..  // 改变文件的所有权
例：chown -R yuhao:yu dir        // 将文件（或目录dir的所有文件）改为yu组用户yuhao所有


24)查看系统版本
a. 查看内核版本命令： 
1) cat /proc/version 
2) uname -a 
3) uname -r 
 
b.查看linux版本： 
1) lsb_release -a ,即可列出所有版本信息，找不到该命令，可以yum install redhat-lsb
   注:这个命令适用于所有的linux，包括Redhat、SuSE、Debian等发行版。
2) cat /etc/issue
 
c.查看服务器位数
# arch

25)tr文本转换命令（从stdin读入数据）
tr [options] set1 set2
其中[options]:
-c 除了set1所表示的字符不替换，其它字符平均替换为set2字串表示的最后一个字符
-d 删除所有set1输入字符。
-s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。
例子：
echo "HELLO WHO IS THIS" | tr 'A-Z' 'a-z'							// 大写替换为小写
echo "HELLO WHO IS THIS" | tr ' ' '\n'		  					// ' '替换为'\n'
echo ge pnzr, ge fnj, ge pbadhrerq. | tr 							// 可实现循环右移加密
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'

echo "HELLO WHO IS THIS" | tr -d 'IS'									// 册除所有字符为'I'或'S'的字符
echo "HELLO        THIS" | tr -s ' '									// 册除所有重复出现字符‘ ‘（只保留一个' '）
echo "HELLO123     THIS" | tr -c '123' 'XYZ*'         // 除了字符'1','2','3',其它字符的都被'*'替换

26)cut打印每行选择的部分（即选择列）
cut [option]... [file]
其中
[file]指定输入文件，如果缺省则为stdin
[option]:
-b [list]										// 先择[list]指字的byte
-c [list]										// 先择[list]指字的字符
-f [list]	  								// 选择[list]指定的域（如果没有-s选项，没有分隔符的行也打印）
-d [delimiter]							// 指定域分隔符(默认为TAB)	
-s													// 不打印没有分隔符的行
--output-delimiter=STRING  	// 使用STRING作为打印分隔符（缺省使用输入分隔符）
C-complement
注
1)-b, -c, -f选项不能同时出现，只能选其一。
2)[list]指定一个范围或逗号分隔的多个范围， 每个范围是如下之一：
N     N'th byte, character or field, counted from 1
N-    from N'th byte, character or field, to end of line
N-M   from N'th to M'th (included) byte, character or field
-M    from first to M'th (included) byte, character or field	

例子：
$ cat student_data.txt					// 
No	Name 	Mark	Percent
1 	Sarath	45 	90
2 	Alex 		49 	98
3 	Anu 		45 	90

$ cut -f1 student_data.txt			// 选择第1列
No
1
2
3

$ cut -f2,4 student_data.txt		// 选择第2，4列
Name		Percent
Sarath 	90
Alex 		98
Anu 		90

$ cut -f3 C-complement student_data.txt
No 	Name 		Percent
1 	Sarath 	90
2 	Alex 		98
3 	Anu 		90

$ cat range_fields.txt	
abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz

														// 选择1-3,6-9位置的字符，以","作为分隔符输出
$ cut range_fields.txt -c1-3,6-9 --output-delimiter ","
abc,fghi
abc,fghi

27)sed（文本流编辑）
基本语法：
sed [address-range]/<pattern>/<action> <files>
对匹配正则表达式<pattern>的行执行<action>, 如果<files>不存在则从标准输入读取。
默认情况下，sed将结果输出到标准输出, 加-i选项可改变。常用action有：
p   打印行（除了打印匹配的行，默认情况下会将所有行都打印出，可加-n选项只打印匹配行）
d   删除行
a\  增加行（将当前选中的行后面插入一行字符串s，行的选择：1表示第1行，2表示第2行，...，　$表示最后一行，1,3表示第１到第３行，2,$表示第２到最后一行）
i\  插入行（将当前选中的行前面插入一行字符串s）
c\  替换行（将当前选中的行替换成字符串s）

s/<pattern1>/<pattern2>/　替换（用<pattern2>替换<pattern1>）

sed -e <cmd1> -e <cmd2> ... -e <cmdn> <files>
使用-e选项可以对<files>中每个文件依次执行<cmd1>, <cmd2>,...,<cmdn>其中，<cmdx>为前述的/<pattern>/<action>形式

增加使用举例
sed '/hello/a\world'	// 匹配hello的行后增加world（加入的内容单独为一行，加入多行可以\n分隔）
sed '3,$ a\world'		// 第3行到最后一行每行后面加入world
sed '3,$ d'				// 删除第3行到最后一行的所有内容

替换使用举例（略去/<pattern>/s/<pattern1>/<pattern2>/前的/<pattern>/表示不考虑行是否匹配<pattern>）
sed 's/pattern/replace_string/' input-file		// 用replace_string替换每行第1个pattern，pattern可为正则表达式
sed 's/pattern/replace_string/g' input-file		// 用replace_string替换每行所有的pattern
sed 's|pattern|replace_string|g' input-file		// 功能同上，可使用其它分隔符如"|"

// 以下两操作等价（使用-i选项），功能都是用replace替换file中的text
sed 's/text/replace/' file > newfile; mv newfile file
sed -i 's/text/replace/' file

// 注：g表示全局夫换，Ng表示从第N个匹配处开始替换
$ echo this thisthisthis | sed 's/this/THIS/g'
THIS THISTHISTHIS
$ echo this thisthisthis | sed 's/this/THIS/2g'
this THISTHISTHIS
$ echo this thisthisthis | sed 's/this/THIS/3g'
this thisTHISTHIS
$ echo this thisthisthis | sed 's/this/THIS/4g'
this thisthisTHIS

sed '/^$/d' file	 // 删除file中的空行（^$匹配空行）

// 使用引用&（\w\+表示匹配单词，&表示引用匹配）
$ echo this is an example | sed 's/\w\+/[&]/g'
[this] [is] [an] [example]

// 使用子模式引用\n（\1表示引用正则表达式digit \([0-9]\)的第1个子模式）
$ echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
this is 7 in a number

// 体会以下例子及输出(用第2、第1个子模式替换第1，第2个子模式)
$ echo seven EIGHT | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'
EIGHT seven

注：使用-r选项指示扩展的正则表达式:), 这样上例可这样写：
$ echo seven EIGHT | sed -r 's/([a-z]+) ([A-Z]+)/\2 \1/'
EIGHT seven


28）awk（处理数据流的工具）
(1)awk的语法有两种形式
awk [options] 'script' var=value file(s)
awk [options] -f scriptfile  var=value file(s)

其中script是由模式和操作组成的：pattern {action} ，一般用单/双引号括起来
'BEGIN{ print "start" } /pattern1/{ action } /pattern2/{action2} END{ print "end" }’
“BEGIN{ print "start" } /pattern1/{ action } /pattern2/{ action2} END{ print "end" }”
两者是可选的，如果没有模式，则action应用到每条记录，否则只应用到模式匹配的记录
如果没有action，则print每条记录(相当于print $0)。默认情况下，每一个输入行都是一条记录，但用户
可通过RS变量指定不同的分隔符进行分隔。BEGIN和END可看成特殊的模式，匹配文件开头和结尾。

注：事实上模式可以是如下比较操作符连接的逻辑表达式：
>, >=, <, <=, ==, !=    // 6种数字比较操作符
value ~ /pattern/       // value匹配模式
value !~ /pattern/      // value不匹配模式

单个逻辑表达式，可用“&&”或"||"组成复合表达式，注意加括号，如下：
awk 'NR <= 20 {print;}'                      //  打印前20行
awk '(NR <= 20) && (NR >= 10) {print; }'     //　打印第10-20行

(2)awk执行过程：
a. 执行 BEGIN { action }.
b. 从stdin或文件读取一条记录(缺省情况下记录就是行)，若pattern1匹配记录，执行action1;
  若pattern2匹配记录，执行action2;
c. 读取下一条记录，重复b操作, 至读取到文件尾
c. 执行END { action }

注：
// 逗号分隔的参数，print以空格作为域输出符（echo会输出一个换行符到stdout)
$ echo | awk '{ var1="v1"; var2="v2"; var3="v3"; print var1,var2,var3 ; }'
v1 v2 v3

// 双引号作为print的连结操作符
$ echo | awk '{ var1="v1"; var2="v2"; var3="v3"; print var1"-"var2"-"var3; }'
v1-v2-v3

// 模式一般写在/.../之间，如: 以root开头的行, 打印第7个域
# awk -F: '/^root/{print "user: "$1" shell:"$7}' /etc/passwd             
user: root shell:/bin/bash

// print和printf
// awk中同时提供了print和printf两种打印输出的函数。
// print的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。
// printf的用法和c语言中printf相似,可以格式化字符串, 输出复杂时, printf更加好用:)
awk -F: '/^root/{printf("user=%s,shell=%s,file=%s", $1, $7, FILENAME)}' /etc/passwd
user=root,shell=/bin/bash,file=/etc/passwd

(3)特殊变量
FILENAME：当前处理的文件名（不应改变该变量值）
NR: 表示记录的当前行号（不应改变该变量值）
NF：当前行执行中记录的域的数目（不应改变该变量值）
FS：输入域分隔符（默认空格或Tab）
OFS：输出域分隔符（默认空格, 比如：print $1, $2的输出会在第１个域和第２个域之间加空格）
RS：输入记录分隔符（默认换行符）
ORS：输出记录分隔符（默认换行符）
$0: 当前行中的文本
$1：当前行中的文本的第1个域
$2：当前行中的文本的第2个域
length: 当前行中字符的个数
例子：
$ echo -e "line1 f2 f3\nline2 f4 f5\nline3 f6 f7" | awk '{print "Line no:"NR",Number of fields:"NF, "$0="$0, "$1="$1,"$2="$2,"$3="$3}'
Line no:1,Number of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3
Line no:2,Number of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5
Line no:3,Number of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7

$awk '{ print $3,$2 }' file			// 打印file中每行的第3，第2个域
$awk 'END{ print NR }' file			// 打印file的行数

(4) 传递变量给awk
// 方式1：使用-v选项
$var=100; echo | awk -v x=$var '{print x}'
100
// 方式2：
$var1="Variable1"; var2="Variable2"; echo | awk '{ print v1,v2 }' v1=$var1 v2=$var2
Variable1 Variable2

(5)显示使用getline读取一行
语法：getline var
如果var省略，可通过$0, $1, 和$2等访问相关域，例：
$ seq 3 | awk 'BEGIN { getline; print "Read ahead first line", $0 } {print $0 }'
Read ahead first line 1
2
3

(6)设置域分隔符
$awk -F: '{ print $NF }' /etc/passwd					// 将分隔符设为：打印每行最后一个域
$awk 'BEGIN { FS=":" } { print $NF }' /etc/passwd		// 功能同上
注：可通过OFS="delimiter"设置print分隔符

(7)从awk读取命令输出
语法："command" | getline output;
例：
$ echo | awk '{ "grep root /etc/passwd" | getline cmdout ; print cmdout}'
root:x:0:0:root:/root:/bin/bash

(8)使用for循环
for(i=0;i<10;i++) { print $i ; }
for(i in array) { print array[i]; }

(9)字符串处理
length(string): 						返回string的长度
index(string, search_string): 			返回search_string在string中的位置
split(string, array, delimiter): 		用delimiter分隔string产生的结果存放于array
substr(string, start-position, end-position): 返回一个子串
sub(regex, replacement_str, string): 	替换第一个匹配regex的字符串
gsub(regex, replacment_str, string: 	替换所有匹配regex的字符串
match(regex, string): 			string中存在匹配regex（RSTART保存匹配的位置，RLENGTH保存匹配的长度），返回非0，否则返回0.
srand([seed])                           初始化随机数（可传入seed, 为空表示使用系统时间作为种子）
rand()                                  产生随机数（0～1之间）
注：内建的shell变量RANDOM可以产生0～32767之间的随机整数（如执行命令：echo $RANDOM显示一个不同的随机数）

(10)其它
if/else, while、do/while、for、break、continue用法与C语言一样
awk中数组的下标可以是数字和字符串(称为key)。存储在内部的一张针对key/value应用hash表里。由于hash不是顺序存储，因此显示数组内容时会发现，可能并不是你预料的顺序显示。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等
awk -F ':' 'BEGIN{count=0;} {name[count]= $1;count++;}; END{for(i = 0; i < NR; i++)print i, name[i]}' /etc/passwd
0 root
1 daemon
2 bin
3 sys
...

29) diff（比较文件）
(1)用法：
	diff [options] file1 file2
	diff [options] file1 directory
	diff [options] directory file2
	diff [options] directory1 directory2
	
	说明：file1, file2是比较文件的路径。如果其中一个参数是目录，则在此目录中搜索与另一文件同名的文件进行比较。
				如果两个参数都是目录，则比较两个目录下同名的文件。

(2)diff假定你想转换file1到file2, 输出格式是一些指示,如下表：
 
	--------------------------------------------------------------------------------
	输入指示								意义 (转换file1到file2)
	--------------------------------------------------------------------------------
	line1 a line2,line3				    在file1的line1后面增加file2中line2到line3行的内容
	> lines from file2			        （形如“line2,line3”逗号分隔表示范围，line1表示单行）			
	--------------------------------------------------------------------------------
	line1,line2 d line3					删除file1中的line1至line2行
	< lines from file1                  需删除的file1中的内容
	--------------------------------------------------------------------------------
	line1,line2 c line3,line4			用file2的line3至line4行替换file1的line1至line2行
	< lines from file1                  文件file1中被替换的内容
	CCC
	> lines from file 2                 文件file2中替换后的内容
	--------------------------------------------------------------------------------
 
(3)举例
例1：
$ cat m
aaaaa
bbbbb
ccccc

$ cat n
aaaaa
ccccc

$ diff m n
2d1				        // 删除文件m中的第二行					
< bbbbb			        // <指出比较第1个文件（即m）

$ diff --side-by-side --width=30 m n		// 以对比格式输出m,n的不同
aaaaa aaaaa
bbbbb <
ccccc ccccc

$ sdiff -w 30 m n	    // 	sdiff等价于diff --side-by-side										
aaaaa aaaaa
bbbbb <
ccccc ccccc

$ cat p
aaaaa
bbbbb
rrrrr
ccccc

$ diff m p															
2a3						// 在m第2行后增加p中第3行内容
> rrrrr				    // >指出p中第3行的内容为rrrrr

$ cat r
aaaaa
-q
ccccc
$ diff m r
2c2						// 用r第2行替换m的第2行
< bbbbb			        // <指出m中第2行的内容为bbbbb
---					    // 分隔线
> -q					// >指出r中第2行的内容为-q

$ cat q 				$ cat v								// 文件q,v的内容如下
Monday 					Monday
Tuesday 				Wednesday
Wednesday 			Thursday
Thursday 				Thursday
Saturday 				Friday
Sunday 					Saturday
Sundae

$ diff -y -W 30 q v
Monday 				Monday
Tuesday 			<												// 删除此行
Wednesday 		Wednesday
Thursday 			Thursday
							> Thursday							// >指示增加此行为Thursday
							> Friday								// >指示增加此行为Friday
Saturday 			Saturday
Sunday 				| Sundae								// |指示改变此行为Sundae


$ diff --context q v									// 以块形式输出比较结果
*** q Mon Aug 24 18:26:45 2009
--- v Mon Aug 24 18:27:55 2009
***************
*** 1,6 ****
Monday
- Tuesday
Wednesday
Thursday
Saturday
! Sunday
--- 1,7 ----
Monday
Wednesday
Thursday
+ Thursday
+ Friday
Saturday
! Sundae

29) xargs(参数处理)

(1) 转换多行输入至单行输出
$ cat example.txt
1 2 3 4 5 6
7 8 9 10
11 12
$ cat example.txt | xargs
1 2 3 4 5 6 7 8 9 10 11 12

(2) 转换单行输入至多行输出（-n 指定每行输出的最大参数个数）
$ cat example.txt | xargs -n 3
1 2 3
4 5 6
7 8 9
10 11 12

(3) -d选项指定参数分隔符
$ echo "splitXsplitXsplitXsplit" | xargs -d X
split split split split
$ echo "splitXsplitXsplitXsplit" | xargs -d X -n 2
split split
split split
注：有时需要以null字符(0)作为分隔符(文件名中含有空格、引号、反斜扛), 可使用-0选项
指定。这也常配合find -print0使用。

(4)传递格式化参数至命令行
#!/bin/bash
#Filename: cecho.sh
echo $*'#'
$ cat args.txt
arg1
arg2
arg3
$ cat args.txt | xargs -n 1 ./cecho.sh
arg1 #
arg2 # 
arg3 #
$ cat args.txt | xargs -n 2 ./cecho.sh
arg1 arg2 #
arg3 #
$ cat args.txt | xargs ./ccat.sh
arg1 arg2 arg3 #

(5) -I {} 指定参数替换
$ cat args.txt | xargs -I {} ./cecho.sh -p {} -l
-p arg1 -l #
-p arg2 -l #
-p arg3 -l #

30) ssh
ssh yuhao@10.69.2.247                     // 连接服务器10.69.2.247(-p <port>指定端口，默认22), 提示输入密码.
scp -rv ./dir yuhao@10.69.2.247:/home/yuhao     // 将mydir拷至服务器的/home/yuhao目录下
scp yuhao@10.69.2.247:/home/yuhao/myfile ./myfile // 将服务器/home/yuhao/myfile拷到当前目录

sshfs user@remotehost:/home/path /mnt/mountpoint    // mount一个ssh目录
umount /mnt/mountpoint                              // 取稍挂载

31) iconv (文件格式转换)
iconv -f GBK -t UTF8 <src-file> -o <dst-file>       // 将<src-file>从GBK转换成UTF8格式并保存到<dst-file>

32) curl
curl http://www.centos.org > centos-org.html 　      // 下载单个文件，默认输出到stdout
curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html  // -o选项指定保存的文件名
curl -O http://www.gnu.org/software/gettext/manual/gettext.html                 // -Ｏ选项指定保存为URL中包含的文件名（gettext.html）
curl -O URL1 -O URL2                                // 一次下载多个文件　
curl -L http://www.google.com                       // -L选项，使得自动重定向到"google.co.hk", 比如我们在国内访问google.com
curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html    // 使用“-C -”继续下载，或-C <offset>指定从哪里下载　　 
curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php         // 从FTP服务器下载文件
curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/                // 列出public_html目录下的所有文件和子目录
curl ftp://ftp.uk.debian.org/debian/pool/main/[a-z]/　                   // 下载匹配的所有文件，这里使用[a-z]
curl -u ftpuser:ftppass -T "{file1,file2}" ftp://ftp.testserver.com     // 上传多个文件到FTP服务器，这里使用{}匹配

// --digest指定HTTP Digest认证, -X指定方法，-H指定Header -d指定body(或body文件)
curl --digest -H "Content-Type: application/xml" -X PUT -d @record.xml user:pwd@host:port/path 
curl --digest -H "Content-Type: application/xml" -X Post -d '...body data..' user:pwd@host:port/path



33) tftp配置(ubuntu12.04下先切换到root用户)
1) 安装tftp-hpa tftpd-hpa xinetd
＃apt-get install tftp-hpa tftpd-hpa xinetd

2) 创建tftp服务目录
#mkdir /tftpboot
#chmod -R 777 /tftpboot

3) 修改tftp配置文件（如果没有就创建）
#vim  /etc/xinetd.d/tftp
文件内容：
service tftp
{
    disable         = no
    socket_type     = dgram
    protocol        = udp
    wait            = yes
    user            = root
    server          = /usr/sbin/in.tftpd
    server_args     = -s /tftpboot         // 指定tftp服务目录
    source          = 11
    cps             = 100 2
    flags =IPv4
}

4) 修改inetd.conf文件
# vim /etc/inetd.conf
一般这个文件里面是有内容的, 在文件末尾添加以下内容即可：
tftp  dgram    udp    wait    nobody    /usr/sbin/tcpd
/usr/sbin/in.tftpd   /tftpboot

5) 修改tftpd-hpa文件
# vim /etc/default/tftpd-hpa
文件内容：
TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/tftpboot"
TFTP_ADDRESS="0.0.0.0:69"
TFTP_OPTIONS="-l -c -s"

6) 重启服务
# service tftpd-hpa restart
# sudo /etc/init.d/xinetd reload
# sudo /etc/init.d/xinetd restart

7) 本地测试
#tftp 127.0.0.1
tftp>get test1.txt   // 从/tftpboot下载test1.txt
tftp>put test2.txt   // 上传test2.txt到/tftpboot/

34) ed（面向行的文本编辑工具，从标准输入读取编辑命令）
语法：
ed file < ed-cmd.script

其中ed-cmd.script为ed命令脚本,比如:
g/search/s/search/replace/g
w
q
类似于vi，这里w表示保存， q表示退出
 
注: 
1) ed有两种模式，command模式和input模式.
在command模式下, ed从标准输入读取命令并执行，当读到`a' (append), `i' (insert) 或 `c' (change)时，
ed进入input模式，此模式无命令可用，ed从标准输入读取内容写入文件（包括换行符），将用户输入'.'命令时，
input模式终止.
2) ed命令运用于所用行或某个范围的行，例如'd' -删除行，'m' －移动行
一般而言, ed命令包括0或多个行地址，后面跟单字符命令，再接可选的参数，命令结构如下：
[address [,address]]command[parameters]
其中address(es)表示命令操作的行或某个范围的行.
例子：
1）'s'命令查找和替换文件
g/search1/s/search2/replace/g
意义：
g           第一个g表示查找和替换所有匹配search1的行（省略只查找第一个匹配search1的行）
search1     查找的包含search1的行
s           表示查找替换命令
search2     对包含search1的行再搜索search2
replace     用replace替换search2
g           最后一个g表示用replace替换所有的search2的（省略只替换第一个search2）

2) 'a'命令添加文本
/<patern>
a
<something-to-be-added>
.
意义：搜索pattern匹配的行，在其后添加文本<something-to-be-added>, 最后的.表示终止输入模式

3）'d'命令删除文本
g/<want-to-be-deleted-txt>/d
意义：删除所有匹配<to-be-deleted-txt>的行

35) dd
dd用于拷贝文件，转换或格式化
用法: 
dd [OPERAND]... 或 dd OPTION
其中：
if=FILE         从FILE读（缺省从stdin读）
of=FILE         写入到FILE（缺省写入stdout）
ibs=BYTES       一次读入BYTES字节(即读入缓冲区大小，缺省512字节，即设置读入块的大写）
obs=BYTES       一次写入BYTES字节(即写入缓冲区大小，缺省512字节，即设置写入块的大写）
bs=BYTES        同时设置读/写缓冲区的字节数（即设置ibs和obs相等）
cbs=BYTES       一次转换BYTES字节
count=BLOCKS    只拷贝输入的BLOCKS块
seek=BLOCKS     从输入文件开头跳过BLOCKS个块后再开始复制
skip=BLOCKS     从输出文件开头跳过BLOCKS个块后再开始复制
iflag=FLAGS     指定读取标识（多个标识用逗号分隔）
oflag=FLAGS     指定写入标识（多个标识用逗号分隔）
status=noxfer   禁止转化过程中的统计信息
conv=CONVS      从指定的参数（用逗号分隔）转换文件
其中：
BLOCKS和BYTES后面可接单位: c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, 
xM =M GB =1000*1000*1000, G =1024*1024*1024, 其它单位，如T, P, E, Z, Y等类似理解

CONV可以是:
ascii   将EBCDIC转化为ASCII
ebcdic  将ASCII转化为EBCDIC
ibm     将ASCII转化为alternate EBCDIC
block   把每一行转换为长度为cbs，不足部分用空格填充
unblock 使每一行的长度都为cbs，不足部分用空格填充
lcase   把大写字符转换为小写字符
ucase   把小写字符转换为大写字符
swab    交换输入的每对字节
noerror 出错时不停止
notrunc 不截短输出文件
sync    将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。

FLAG可以是：
append    Append模式 (只对输出有意义 建议conv=notrunc)
direct    使用direct I/O传输数据(data)
dsync     使用synchronized I/O传输数据(data)
sync      同上，但是针对元数据(metadata)
nonblock  使用non-blocking I/O传输数据(data)
noatime   不更新access time
nocache   放弃cached data

35) stat（显示文件或文件系统状态）
用法: 
stat [OPTION]... FILE...
其中:
[OPTION]:
  -L, --dereference     如果是链接文件，则获取原文件信息
  -f, --file-system     显示文件所在的文件系统（而不是文件）的状态
  -c  --format=FORMAT   指定格式FORMAT（格式后面输出换行）
      --printf=FORMAT   同上，但不输出换行符（换行符\n需在FORMAT中指定）
  -t, --terse           以简洁的形式打印输出信息
有效的FORMAT（只针对文件，即-f选项未指定时适用）
  %a   访问权限（8进制）
  %A   访问权限（可读形式）
  %b   分配的块（block）数 (ls -l情况下显示的样子）
  %B   每块（block）尺寸
  %C   SELinux安全
  %d   设备号（10进制）
  %D   设备号（16进制）
  %f   Raw mode（16进制）
  %F   文件类型
  %g   所有者组ID
  %G   所有者组名
  %h   硬链接数
  %i   Inode号
  %m   挂载点
  %n   文件名
  %N   Quoted file name with dereference if symbolic link
  %o   I/O block大小
  %s   文件大小（bytes）
  %t   主要设备类型（十六进制）
  %T   次要设备类型（十六进制）
  %u   所有者的用户ID
  %U   所有者的用户名
  %w   Time of file birth, human-readable; - if unknown
  %W   Time of file birth, seconds since Epoch; 0 if unknown
  %x   最后一次访问时间（可读形式） 
  %X   最后一次访问时间（自大纪元Epoch开始的秒数）  
  %y   最后一次修改时间（可读形式）
  %Y   最后一次修改时间（自大纪元Epoch开始的秒数）  
  %z   最后一次状态改变时间（可读形式） 
  %Z   最后一次状态改变时间（自大纪元Epoch开始的秒数）
有效的FORMAT(只针对文件系统)
  %a   对普通用户可用的Free block数
  %b   总的data block数
  %c   总的file node数
  %d   Free file node数
  %f   Free block数
  %i   文件系统 ID （16进制）
  %l   文件名最大长度
  %n   文件名
  %s   Block大小 (for faster transfers)
  %S   Fundamental block大小(for block counts)
  %t   类型（16进制）
  %T   类型（可读形式）

举例：
stat -c%s  <file>   // 获取文件大小（bytes）

注：访问时间／修改时间／状态改变时间
访问时间：读一次这个文件的内容，这个时间就会更新。比如more、cat等, ls、stat则不会修改访问时间。
修改时间：文件内容最后一次被修改时间。比如：vi后保存文件，ls -l列出的就是这个时间。
状态改变时间：文件的inode节点最后一次被修改的时间，比如通过chmod、chown等

36) m4
GNU m4是一个宏预处理器，主要执行宏替换，内建很多功能函数（如文件操作，字符串处理，算术运算等）
语法：
m4 [OPTION]... [FILE]
处理FILE中的宏，如果FILE为'-'或缺省, 则从标准输入中读取，m输出可重定向到文件, 如:
m4 file.m4 > output_file
应用例子：
例１
输入：
one
define(`one', `ONE')dnl
one
define(`ONE', `two')dnl
one ONE oneONE
`one'
输出：
one
ONE
two two oneONE
one
说明：
1) m4拷贝输入到输出，扫描每个token看否它是一个宏名，如果是则执行替换（将前面定义的宏依次替换），
引号串如：` text'则不会宏扩展。
2) `'作为标准分隔符
3) define()函数用于定义宏
4) dnl(delete to new line): 删除直到换行符, 否则会输出很多空行

例２
输入：
define(`my_value',`$1_file')dnl
my_value(`test')
输出：
test_file
说明：$1,$2,...分别表示宏的第1个参数，第2个参数, ...

例3
ifelse(`first_text',`second_text',`true_action',`false_action')
说明：条件输出. 如果first_text等于second_text，则输出true_action，否则输出false_action

例４
include('xxx.m4')

说明：include()函数用于文件包含

例５
define(`my_sidebar',`include(content/$1_sidebar)')
说明：宏可嵌入宏

例6
divert(-1)
define(`my_macro1',
    `some_macro_expansion'
)
define(`my_macro2',
    `another_macro_expansion'
)
divert
说明：为为避免输出空行，divert(-1)将输出重定义到-1（即不存在的东西如/dev/null），divert用于恢复原始输出

37)进程资源相关命令(摘自How linux works) 
top: 显示当前系统中进程的CPU/内存使用情况, 优化级／nice值等
　　　按键: h-帮助（显示其它按键的作用），Ｍ-按内存排序，Ｐ-按CPU排序，ｕ-仅排序某个用户的进程
     　top -p pid     显示某个进程CPU使用情况
      top -H -p pid 　显示线程信息

lsof: 列出进程打开的文件（lsof -p pid 列出某个进程打开的文件）
strace: 跟踪某个应用系统调用（如：strace cat /dev/null）
ltrace: 跟踪某个应用对库函数的调用
ps： ps m -o pid,tid,command 显示线程相关信息
     ps -l 显示进程优先级
renice：可改变进程的nice值（如:renice 20 pid）
uptime：查看负载均衡（load average）
vmstat: 监视CPU/内存 
iostat: 监视IO
iotop: 针对IO排序进程


38) exp
用法: 
      expr EXPRESSION   // 打印的值到标准输出 
  或: expr OPTION

      --help            // 显示帮助并退出 
      --version         // 输出版本信息并退出

Print the value of EXPRESSION to standard output.  A blank line below
separates increasing precedence groups.  

以下EXPRESSION的优先级逐渐升高:

  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2
  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0

  ARG1 < ARG2       ARG1 is less than ARG2
  ARG1 <= ARG2      ARG1 is less than or equal to ARG2
  ARG1 = ARG2       ARG1 is equal to ARG2
  ARG1 != ARG2      ARG1 is unequal to ARG2
  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2
  ARG1 > ARG2       ARG1 is greater than ARG2

  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2
  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2

  ARG1 * ARG2       arithmetic product of ARG1 and ARG2
  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2
  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2

  STRING : REGEXP   anchored pattern match of REGEXP in STRING

  match STRING REGEXP        same as STRING : REGEXP
  substr STRING POS LENGTH   substring of STRING, POS counted from 1
  index STRING CHARS         index in STRING where any CHARS is found, or 0
  length STRING              length of STRING
  + TOKEN                    interpret TOKEN as a string, even if it is a keyword like 'match' or an operator like '/'

  ( EXPRESSION )             value of EXPRESSION

注：
1）在shell中许多操作符如“< ”需要用“\”转义
2）模式匹配返回\( and \)之间匹配的部分或null，如果REGEXP中未使用\(和\)，则返回匹配的字符数或0
3）命令的返回码： 0 - 如EXPRESSION不为null或0， 1 - EXPRESSION为null， 2 - EXPRESSION语言错误


39) service

service命令运行System V init脚本或upstart job（运行环境：只传递LANG, TERM环境变量给init脚本，并设置当前工作目录为/）
用法：
service SCRIPT COMMAND [OPTIONS]        
service --status-all
service --help | -h | --version
其中：
SCRIPT：　为System V init脚本（/etc/init.d/SCRIPT）或都/etc/init中一个upstart job（注：名字相同时，upstart job优先） 
COMMAND [OPTIONS]：　作为参数原封不动地传给init脚本，所用脚本至少应该的COMMAND包括：start和stop。作为一个特例，如果COMMAND为--full-restart，脚本运行两次：首先运行stop命令, 然后运行start命令
--status-all： 以alphabetical顺序, 用stat作为COMMAND运行所有init脚本


相关目录：
/etc/init.d　包括System V init脚本的目录　
/etc/init　包含upstart jobs的目录

49) systemctl
systemctl可用于查询或发送命令给systemd　(其配置文件称为Unit)，
用法:
systemctl [OPTIONS...] {COMMAND} ...

其中，Unit相关COMMAND:
list-units                      列出所有Unit
start [NAME...]                 Start (或activate)一到多个Unit
stop [NAME...]                  Stop (或deactivate)一到多个Unit
reload [NAME...]                Reload 一到多个unit
restart [NAME...]               Restart（或Start）一到多个Unit
try-restart [NAME...]           Restart（或Start）一到多个Unit（如果Unit处于active状态）
reload-or-restart [NAME...]     Reload一到多个Unit

50) hexdmp (以ASCII, 10/16/8进制形式Dump文件或标准输入――如果无文件指定)
语法：
    hexdump [-bcCdovx] [-e format_string] [-f format_file] [-n length] [-s skip] file ...
    hd [-bcdovx] [-e format_string] [-f format_file] [-n length] [-s skip] file ...
选项：
     -b                 每byte以3个8进制数显示, 每行显示16bytes, 包括左侧16进制形式的input offset 
     -c                 每byte以ASCII字符显示     
     -C                 每byte以Canonical hex　+　ASCII显示
     -d                 每2byte以10进制显示, 每行显示16bytes(8个空格分隔)
     -e format_string　  以指定format显示
     -f format_file     以指定format文件显示
     -n length          显示length　bytes.
     -o                 每2byte以8进制显示, 每行显示16bytes(8个空格分隔)
     -s offset          从offset处开始显示，offset可加k或m后辍，表示kbytes, mbytes      
     -v                 显示所有输入（缺省情况下，相同的行以*表示）
     -x                 每2byte以10进制显示, 每行显示16bytes(8个空格分隔)


51) exec (builtin命令)
语法：
exec [-a NAME] [-cl] [COMMAND] [ARG...] [REDIRECTION...]
功能：
exec用指定程序替换当前shell(而不创建新进程)，可重定向程序或当前shell
注意：如果只有重定向参数，则重定向影响当前shell
选项：
    -a NAME	作为NAME作为参数0传给将要执行的程序
    -c	    在（一个cleared环境下）执行程序Execute the program with an empty (cleared) environment
    -l	    在参数0前加一dash符 (-)
退出码：
    1   错误
    0   成功

注：
1) shell编程中使用exec重定向(参考：http://tldp.org/LDP/abs/html/io-redirection.html)
2) exec N > filename影响整个脚本或当前shell，
        N > filename只影响新fork的进程（而不是整个脚本或shell）

52) netstat
选项：
    -a 显不所有socket信息（包括listening sockect)
    -e 显示extended信息(包括user ID)
    -c　刷新显示（每秒１次）Redisplay socket information continuously (each second)
    -l 显示listening sockets
    -n 以数字形式IP, port, username
    -p 显示进程ID和程序名Show the process ID and name of program to which socket belongs
    --inet  显示Internet domain sockets
    --tcp   显示Internet domain TCP (stream) sockets
    --udp   显示Internet domain UDP (datagram) sockets
    --unix  显示UNIX domain sockets
例子：
$ netstat -a --inet
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 *:48723                 *:*                     LISTEN          
tcp        0      0 test-Dell-Precis:domain *:*                     LISTEN     
tcp        0      0 *:ssh                   *:*                     LISTEN     
tcp        0      0 localhost:ipp           *:*                     LISTEN         
tcp        0      0 localhost:29754         *:*                     LISTEN         
tcp        0      0 localhost:mysql         *:*                     LISTEN     
tcp        0      0 *:netbios-ssn           *:*                     LISTEN     
tcp        0      0 localhost:5037          *:*                     LISTEN     
tcp        0      0 *:44143                 *:*                     LISTEN     
tcp        1      0 10.69.2.37:59223        productsearch.ubu:https CLOSE_WAIT 
tcp        1      0 linkun75e0.ygomi.:60108 productsearch.ubu:https CLOSE_WAIT 
tcp        0      0 10.69.2.37:34359        cncdit01.ygomi:http-alt ESTABLISHED
解释：
Proto               协议，如tcp, udp
Recv-Q              接收Buffer中的字节数
Send-Q              发送Buffer中的字节数
Local Address       本地socket　Bind的地址，主机部分的＊表示wildcard　IP地址
Foreign Address     peer socket地址，*:*表示无地址
State               socket状态


53) tcpdump（wireshark是类似的GUI工具）
语法：
    tcpdump [options] [expression]
主要[options]：
    -w file         保存packets到file 
    -A              以ASCII文本显示每个packet(不包括link level header), 适用于捕获web pages.
    -B buffer_size  设置系统caputre buffer size 单位KiB (1024 bytes).
    -c              收到count个packets后退出（如果此选项未指定，则在收到SIGINT, SIGTERM后退出）
    -t              不显示timestamp
注：更多options参见man页
功能：
显示网络packets内容描述信息，可通过expression过滤packest.　每行显示一个TCP packet或segment，格式如下：
    src > dst : flags data-seqno ack window urg < options >
其中：
    src         源IP和Port
    dst         目的IP和Port
    flags       １到多个TCP control bits：　S (SYN),　F (FIN), P (PSH), R (RST), E (ECE), and C (CWR).
    data-seqno  packet的sequence-number范围（缺省情况下sequence-number是相对的，-S选项显示absolute格式）
    ack         ACK num　表示回复的num
    win         Win num 表示接收buffer可用的bytes空间
    urg         Urg num　表示包含urgent数据
    options     表示packet包含的Tcp options
注：src, dst, flags总是显示，其它可选
   
用法举例：
    tcpdump host sundown                        // 显示所有（到达或离开）sundown的packets
    tcpdump host helios and \( hot or ace \)    // 显示helios和hot之间，helios和ace之间的packets        
    tcpdump ip host ace and not helios          // 显示所有IP packets（ace与除helios之外的所有host之间）
    tcpdump 'tcp port 80'                       // 显示所有到达80端口的IPv4 HTTP packets

rlogin过程从主机rtsg到csam的部分：
    rtsg.1023 > csam.login: S 768512:768512(0) win 4096 <mss 1024>
    csam.login > rtsg.1023: S 947648:947648(0) ack 768513 win 4096 <mss 1024>
    rtsg.1023 > csam.login: . ack 1 win 4096
    rtsg.1023 > csam.login: P 1:2(1) ack 1 win 4096
    csam.login > rtsg.1023: . ack 2 win 4096
    rtsg.1023 > csam.login: P 2:21(19) ack 1 win 4096
    csam.login > rtsg.1023: P 1:2(1) ack 21 win 4077
    csam.login > rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
    csam.login > rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1

54) w/who/users/last (查看当前logined用户信息)
w           显示当前login用户及进程信息（读取var/run/utmp文件获得）.
who         显示当前login用户及进程信息
whoami      显示自己是哪个用户（或who am i）
users       显示当前login用户列表  
last        显示用户login历史



55) dpkg (package manager for Debian)
用法：
       dpkg [option...] action
功能：
dpkg用于建立、安装、移除及管理Debian包，aptitude是更友好的dpkg前端，dpkg以命令形式运行：命令接1个action和0到多个option. dpkg也作为dpkg-deb和dpkg-query的前端运行（当遇到某些actoin时）
dpkg维护了available包的信息，这些信息主要分为三类:
a. Package states
       not-installed    包未安装
       config-files     只有配置文件存在　
       half-installed　  安装已开始，但未完成
       unpacked         已解包，但未配置
       half-configured  已解包，配置已开始但未完成
       triggers-awaited 包等待其它包触发　
       triggers-pending 包已触发
       installed        已安装

b. Package selection states
       install          包被选择为安装  
       hold             包被标记为hold (不能处理，如果未指定--force-hold)  
       deinstall        包被选择卸载（删除除配置之外的所有文件）
       purge            包被选择为purged (删除包括配置在内的所有文件).

c. Package flags
       reinst-required  包已经broken需要重新安装（此包不能被删除，除非指定--force-remove-reinstreq）
  
action:
    -i, --install <package-file>    安装包
    --unpack package-file           解压包，但不配置
    -r, --remove　package            移除已安装的包（不删除配置） 
    -P, --purge package             移除已安装包（删除配置）


dpkg-deb actions
    -b, --build directory [archive|directory]       建立包
    -c, --contents archive                          查看包中的内容
    -e, --control filename [directory]              抽取控制信息
    -x, --extract archive directory                 从包中抽取文件
    -X, --vextract archive directory                抽取并显示文件名
    -I, --info archive [control-file...]            显示包信息

dpkg-query actions
    -l, --list package-name-pattern...              列出匹配模式的包.
    -s, --status package-name...                    显示包状态
    -L, --listfiles package-name...                 列出包所安装的文件.
    -S, --search filename-search-pattern...         从安装包中搜索（指定模式）文件
    -p, --print-avail package-name...               打印包的详细信息



